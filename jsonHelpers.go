//This Source Code Form is subject to the terms of the Mozilla Public
//License, v. 2.0. If a copy of the MPL was not distributed with this
//file, You can obtain one at http://mozilla.org/MPL/2.0/.

package wolframalpha

import (
	"bytes"
	"encoding/json"
	"errors"
)

//──────────────────────────────────────────────────────────────────────────────
//These functions are necessary for mashalling and unmaralling "unions". In this
//case, a union is a case where wolframalpha sends you either two different
//types in different scenarios (e.g. a bool vs an object), or a single element
//vs an array of elements
//(e.g. {foo: {bar: baz}} vs {foo: [{bar: baz}, {bar: qux}]})
//these need to be [un]marshaled in a special way
//
//! IMPLEMENTATION FOR MOST GENERIC CASE - AUTOGENERATED BY HTTPS://QUICKTYPE.IO
//──────────────────────────────────────────────────────────────────────────────

func unmarshalUnion(
	data []byte,
	ptrInt **int,
	ptrFloat **float64,
	ptrBool **bool,
	ptrString **string,
	hasArray bool,
	ptrArray interface{},
	hasObject bool,
	ptrObject interface{},
	hasMap bool,
	ptrMap interface{},
	hasEnum bool,
	ptrEnum interface{},
	nullable bool,
) (bool, error) {
	if ptrInt != nil {
		*ptrInt = nil
	}
	if ptrFloat != nil {
		*ptrFloat = nil
	}
	if ptrBool != nil {
		*ptrBool = nil
	}
	if ptrString != nil {
		*ptrString = nil
	}

	dec := json.NewDecoder(bytes.NewReader(data))
	dec.UseNumber()
	tok, err := dec.Token()
	if err != nil {
		return false, err
	}

	switch v := tok.(type) {
	case json.Number:
		if ptrInt != nil {
			i, err := v.Int64()
			if err == nil {
				iNormalInt := int(i)
				*ptrInt = &iNormalInt
				return false, nil
			}
		}
		if ptrFloat != nil {
			f, err := v.Float64()
			if err == nil {
				*ptrFloat = &f
				return false, nil
			}
			return false, errors.New("Unparsable number")
		}
		return false, errors.New("Union does not contain number")
	case float64:
		return false, errors.New("Decoder should not return float64")
	case bool:
		if ptrBool != nil {
			*ptrBool = &v
			return false, nil
		}
		return false, errors.New("Union does not contain bool")
	case string:
		if hasEnum {
			return false, json.Unmarshal(data, ptrEnum)
		}
		if ptrString != nil {
			*ptrString = &v
			return false, nil
		}
		return false, errors.New("Union does not contain string")
	case nil:
		if nullable {
			return false, nil
		}
		return false, errors.New("Union does not contain null")
	case json.Delim:
		if v == '{' {
			if hasObject {
				return true, json.Unmarshal(data, ptrObject)
			}
			if hasMap {
				return false, json.Unmarshal(data, ptrMap)
			}
			return false, errors.New("Union does not contain object")
		}
		if v == '[' {
			if hasArray {
				return false, json.Unmarshal(data, ptrArray)
			}
			return false, errors.New("Union does not contain array")
		}
		return false, errors.New("Cannot handle delimiter")
	}
	return false, errors.New("Cannot unmarshal union")
}

func marshalUnion(
	ptrInt *int,
	ptrFloat *float64,
	ptrBool *bool,
	ptrString *string,
	hasArray bool,
	ptrArray interface{},
	hasObject bool,
	ptrObject interface{},
	hasMap bool,
	ptrMap interface{},
	hasEnum bool,
	ptrEnum interface{},
	nullable bool,
) ([]byte, error) {
	if ptrInt != nil {
		return json.Marshal(*ptrInt)
	}
	if ptrFloat != nil {
		return json.Marshal(*ptrFloat)
	}
	if ptrBool != nil {
		return json.Marshal(*ptrBool)
	}
	if ptrString != nil {
		return json.Marshal(*ptrString)
	}
	if hasArray {
		return json.Marshal(ptrArray)
	}
	if hasObject {
		return json.Marshal(ptrObject)
	}
	if hasMap {
		return json.Marshal(ptrMap)
	}
	if hasEnum {
		return json.Marshal(ptrEnum)
	}
	if nullable {
		return json.Marshal(nil)
	}
	return nil, errors.New("Union must not be null")
}

//──────────────────────────────────────────────────────────────────────────────

func (eu *ErrorUnion) UnmarshalJSON(data []byte) error {
	eu.Error = nil
	var c QError
	object, err := unmarshalUnion(data, nil, nil, &eu.Bool, nil, false, nil, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		eu.Error = &c
	}
	return nil
}

func (eu *ErrorUnion) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, eu.Bool, nil, false, nil, eu.Error != nil, eu.Error, false, nil, false, nil, false)
}

//──────────────────────────────────────────────────────────────────────────────

func (et *ExpressionTypes) UnmarshalJSON(data []byte) error {
	et.ExpressionTypeArray = nil
	et.ExpressionType = nil
	var c ExpressionType
	object, err := unmarshalUnion(data, nil, nil, nil, nil, true, &et.ExpressionTypeArray, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		et.ExpressionType = &c
	}
	return nil
}

func (et *ExpressionTypes) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, nil, et.ExpressionTypeArray != nil, et.ExpressionTypeArray, et.ExpressionType != nil, et.ExpressionType, false, nil, false, nil, false)
}

//──────────────────────────────────────────────────────────────────────────────

func (ss *SubSource) UnmarshalJSON(data []byte) error {
	ss.StringArray = nil
	object, err := unmarshalUnion(data, nil, nil, nil, &ss.String, true, &ss.StringArray, false, nil, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
	}
	return nil
}

func (ss *SubSource) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, ss.String, ss.StringArray != nil, ss.StringArray, false, nil, false, nil, false, nil, false)
}

//──────────────────────────────────────────────────────────────────────────────

func (su *SourcesUnion) UnmarshalJSON(data []byte) error {
	su.SourceArray = nil
	su.Source = nil
	var c Source
	object, err := unmarshalUnion(data, nil, nil, nil, nil, true, &su.SourceArray, true, &c, false, nil, false, nil, false)
	if err != nil {
		return err
	}
	if object {
		su.Source = &c
	}
	return nil
}

func (su *SourcesUnion) MarshalJSON() ([]byte, error) {
	return marshalUnion(nil, nil, nil, nil, su.SourceArray != nil, su.SourceArray, su.Source != nil, su.Source, false, nil, false, nil, false)
}
